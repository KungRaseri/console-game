using System;
using System.IO;
using System.Linq;
using FluentAssertions;
using RealmForge.Services;
using RealmForge.ViewModels;
using Xunit;

namespace RealmForge.Tests.ViewModels;

/// <summary>
/// Tests for NameListEditorViewModel (FIXED to match actual API)
/// </summary>
public class NameListEditorViewModelTests_Fixed : IDisposable
{
    private readonly string _testDataPath;
    private readonly JsonEditorService _jsonEditorService;

    public NameListEditorViewModelTests_Fixed()
    {
        _testDataPath = Path.Combine(Path.GetTempPath(), "ContentBuilderTests", Guid.NewGuid().ToString());
        Directory.CreateDirectory(_testDataPath);
        _jsonEditorService = new JsonEditorService(_testDataPath);
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void Should_Load_NameList_Structure_Correctly()
    {
        // Arrange
        var testFile = CreateTestFile();

        // Act
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);

        // Assert
        viewModel.Categories.Should().HaveCount(2, "test file has 2 categories");
        viewModel.Categories.Should().Contain(c => c.Name == "swords");
        viewModel.Categories.Should().Contain(c => c.Name == "axes");
        
        var swordsCategory = viewModel.Categories.First(c => c.Name == "swords");
        swordsCategory.Names.Should().Contain("Excalibur");
        swordsCategory.Names.Should().Contain("Blade of Justice");
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void Should_Skip_Non_Array_Categories_Like_Variants()
    {
        // Arrange
        var testFile = CreateTestFileWithVariants();

        // Act
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);

        // Assert - Should skip "variants" which is a nested object
        viewModel.Categories.Should().HaveCount(2, "should load only array categories, skip 'variants' object");
        viewModel.Categories.Should().NotContain(c => c.Name == "variants");
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void AddName_Should_Add_To_Selected_Category()
    {
        // Arrange
        var testFile = CreateTestFile();
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);
        var category = viewModel.Categories.First();
        viewModel.SelectedCategory = category;
        var initialCount = category.Names.Count;
        viewModel.NewNameInput = "New Sword";

        // Act
        viewModel.AddNameCommand.Execute(null);

        // Assert
        category.Names.Should().HaveCount(initialCount + 1);
        category.Names.Should().Contain("New Sword");
        viewModel.NewNameInput.Should().BeEmpty("input should be cleared after adding");
        viewModel.SelectedName.Should().Be("New Sword", "newly added name should be selected");
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void AddName_Command_Should_Be_Disabled_When_No_Input()
    {
        // Arrange
        var testFile = CreateTestFile();
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);
        viewModel.SelectedCategory = viewModel.Categories.First();
        viewModel.NewNameInput = "";

        // Assert
        viewModel.AddNameCommand.CanExecute(null).Should().BeFalse();
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void RemoveName_Should_Remove_Selected_Name()
    {
        // Arrange
        var testFile = CreateTestFile();
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);
        var category = viewModel.Categories.First();
        viewModel.SelectedCategory = category;
        var nameToRemove = category.Names.First();
        viewModel.SelectedName = nameToRemove;

        // Act
        viewModel.RemoveNameCommand.Execute(null);

        // Assert
        category.Names.Should().NotContain(nameToRemove);
        viewModel.SelectedName.Should().BeNull("selected name should be cleared after removal");
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void AddCategory_Should_Add_New_Category()
    {
        // Arrange
        var testFile = CreateTestFile();
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);
        var initialCount = viewModel.Categories.Count;

        // Act
        viewModel.AddCategoryCommand.Execute(null);

        // Assert
        viewModel.Categories.Should().HaveCount(initialCount + 1);
        viewModel.SelectedCategory.Should().NotBeNull("newly added category should be selected");
        viewModel.SelectedCategory!.Name.Should().Be("new_category");
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void RemoveCategory_Should_Remove_Selected_Category()
    {
        // Arrange
        var testFile = CreateTestFile();
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);
        var categoryToRemove = viewModel.Categories.First();
        viewModel.SelectedCategory = categoryToRemove;

        // Act
        viewModel.RemoveCategoryCommand.Execute(null);

        // Assert
        viewModel.Categories.Should().NotContain(categoryToRemove);
        viewModel.SelectedCategory.Should().BeNull("selected category should be cleared after removal");
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void Save_Should_Persist_Changes_To_File()
    {
        // Arrange
        var testFile = CreateTestFile();
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);
        
        // Pre-create the items subdirectory for save operation
        Directory.CreateDirectory(Path.Combine(_testDataPath, "items"));
        
        viewModel.AddCategoryCommand.Execute(null);

        // Act
        viewModel.SaveCommand.Execute(null);

        // Assert
        var filePath = Path.Combine(_testDataPath, "items", testFile);
        File.Exists(filePath).Should().BeTrue("ViewModel saves to items subdirectory");
        
        var content = File.ReadAllText(filePath);
        content.Should().Contain("new_category", "saved file should contain the added category");
    }

    [Fact]
    [Trait("Category", "ViewModel")]
    public void Cancel_Should_Reload_Data()
    {
        // Arrange
        var testFile = CreateTestFile();
        var viewModel = new NameListEditorViewModel(_jsonEditorService, testFile);
        var originalCount = viewModel.Categories.Count;
        viewModel.AddCategoryCommand.Execute(null);

        // Act
        viewModel.CancelCommand.Execute(null);

        // Assert
        viewModel.Categories.Should().HaveCount(originalCount, "cancel should revert unsaved changes");
        viewModel.SelectedCategory.Should().BeNull();
        viewModel.NewNameInput.Should().BeEmpty();
    }

    private string CreateTestFile()
    {
        var filename = $"test_{Guid.NewGuid()}.json";
        var data = @"{
  ""items"": {
    ""swords"": [
      ""Excalibur"",
      ""Blade of Justice"",
      ""Dragon Slayer""
    ],
    ""axes"": [
      ""Battle Axe"",
      ""War Cleaver""
    ]
  }
}";
        File.WriteAllText(Path.Combine(_testDataPath, filename), data);
        return filename;
    }

    private string CreateTestFileWithVariants()
    {
        var filename = $"test_{Guid.NewGuid()}.json";
        var data = @"{
  ""items"": {
    ""swords"": [
      ""Excalibur"",
      ""Blade of Justice""
    ],
    ""axes"": [
      ""Battle Axe""
    ],
    ""variants"": {
      ""rusted"": ""old and worn"",
      ""pristine"": ""brand new""
    }
  }
}";
        File.WriteAllText(Path.Combine(_testDataPath, filename), data);
        return filename;
    }

    public void Dispose()
    {
        if (Directory.Exists(_testDataPath))
        {
            Directory.Delete(_testDataPath, true);
        }
    }
}
