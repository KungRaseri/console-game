using FluentAssertions;
using Game.Core.Generators.Modern;
using Game.Data.Services;
using Game.Shared.Models;

namespace Game.Core.Tests.Generators;

public class EnemyGeneratorTests
{
    private readonly GameDataCache _dataCache;
    private readonly ReferenceResolverService _referenceResolver;
    private readonly EnemyGenerator _generator;

    public EnemyGeneratorTests()
    {
        var basePath = Path.Combine(Directory.GetCurrentDirectory(), "..", "..", "..", "..", "Game.Data", "Data", "Json");
        _dataCache = new GameDataCache(basePath);
        _referenceResolver = new ReferenceResolverService(_dataCache);
        _generator = new EnemyGenerator(_dataCache, _referenceResolver);
    }

    [Theory]
    [InlineData("beasts")]
    [InlineData("humanoid")]
    [InlineData("undead")]
    [InlineData("constructs")]
    [InlineData("elementals")]
    public async Task Should_Generate_Enemies_From_Category(string category)
    {
        // Act
        var enemies = await _generator.GenerateEnemiesAsync(category, 3);

        // Assert
        enemies.Should().NotBeNull();
        // Some categories might be empty, so we allow empty lists
        
        foreach (var enemy in enemies)
        {
            enemy.Name.Should().NotBeNullOrEmpty();
            enemy.Description.Should().NotBeNullOrEmpty();
            enemy.Id.Should().StartWith(category);
            enemy.Health.Should().BeGreaterThan(0);
            enemy.MaxHealth.Should().BeGreaterThan(0);
            enemy.Attack.Should().BeGreaterOrEqualTo(0);
            enemy.Defense.Should().BeGreaterOrEqualTo(0);
            enemy.Level.Should().BeGreaterThan(0);
        }
    }

    [Fact]
    public async Task Should_Generate_Enemy_By_Name()
    {
        // First, get a list of available enemies to test with
        var enemies = await _generator.GenerateEnemiesAsync("humanoid", 5);
        
        if (enemies.Any())
        {
            var testEnemy = enemies.First();
            var enemyName = testEnemy.Name;

            // Act
            var result = await _generator.GenerateEnemyByNameAsync("humanoid", enemyName);

            // Assert
            result.Should().NotBeNull();
            result!.Name.Should().Be(enemyName);
            result.Id.Should().StartWith("humanoid");
        }
    }

    [Fact]
    public async Task Should_Return_Null_For_Non_Existent_Enemy()
    {
        // Act
        var result = await _generator.GenerateEnemyByNameAsync("humanoid", "NonExistentEnemy");

        // Assert
        result.Should().BeNull();
    }

    [Fact]
    public async Task Should_Generate_Enemies_With_Valid_Combat_Stats()
    {
        // Act
        var enemies = await _generator.GenerateEnemiesAsync("humanoid", 5);

        // Assert
        foreach (var enemy in enemies)
        {
            enemy.Health.Should().BeGreaterThan(0, "Enemies should have positive health");
            enemy.MaxHealth.Should().BeGreaterThan(0, "Enemies should have positive max health");
            enemy.Health.Should().BeLessOrEqualTo(enemy.MaxHealth, "Health should not exceed max health");
            enemy.Attack.Should().BeGreaterOrEqualTo(0, "Attack should not be negative");
            enemy.Defense.Should().BeGreaterOrEqualTo(0, "Defense should not be negative");
            enemy.Speed.Should().BeGreaterOrEqualTo(0, "Speed should not be negative");
            enemy.Level.Should().BeGreaterThan(0, "Enemy level should be positive");
        }
    }

    [Fact]
    public async Task Should_Generate_Enemies_With_Appropriate_Rewards()
    {
        // Act
        var enemies = await _generator.GenerateEnemiesAsync("humanoid", 5);

        // Assert
        foreach (var enemy in enemies)
        {
            enemy.ExperienceReward.Should().BeGreaterOrEqualTo(0, "Experience reward should not be negative");
            enemy.GoldReward.Should().BeGreaterOrEqualTo(0, "Gold reward should not be negative");
            
            // Higher level enemies should generally give more rewards
            if (enemy.Level > 1)
            {
                enemy.ExperienceReward.Should().BeGreaterThan(0, "Higher level enemies should give experience");
            }
        }
    }

    [Fact]
    public async Task Should_Resolve_Ability_References()
    {
        // Act
        var enemies = await _generator.GenerateEnemiesAsync("humanoid", 10);

        // Assert
        var enemiesWithAbilities = enemies.Where(e => e.Abilities?.Any() == true).ToList();
        
        foreach (var enemy in enemiesWithAbilities)
        {
            enemy.Abilities.Should().NotBeNull();
            enemy.Abilities!.Should().NotBeEmpty();
            
            // Abilities should be resolved from @references to actual IDs
            foreach (var ability in enemy.Abilities)
            {
                ability.Should().NotBeNullOrEmpty();
                ability.Should().NotStartWith("@", "References should be resolved to actual IDs");
            }
        }
    }

    [Fact]
    public async Task Should_Handle_Empty_Category_Gracefully()
    {
        // Act
        var result = await _generator.GenerateEnemiesAsync("non-existent-category", 5);

        // Assert
        result.Should().NotBeNull();
        result.Should().BeEmpty();
    }

    [Fact]
    public async Task Should_Generate_Varied_Enemy_Levels()
    {
        // Act
        var enemies = await _generator.GenerateEnemiesAsync("humanoid", 15);

        // Assert
        if (enemies.Count > 1)
        {
            var levels = enemies.Select(e => e.Level).Distinct().ToList();
            // We don't enforce multiple levels since it depends on the data,
            // but each enemy should have a valid level
            foreach (var enemy in enemies)
            {
                enemy.Level.Should().BeInRange(1, 100, "Enemy levels should be reasonable");
            }
        }
    }

    [Fact]
    public async Task Should_Generate_Enemies_With_Descriptions()
    {
        // Act
        var enemies = await _generator.GenerateEnemiesAsync("beasts", 5);

        // Assert
        foreach (var enemy in enemies)
        {
            enemy.Description.Should().NotBeNullOrEmpty("Each enemy should have a description");
            enemy.Description.Length.Should().BeGreaterThan(10, "Descriptions should be meaningful");
        }
    }

    [Fact]
    public async Task Should_Handle_Different_Enemy_Categories()
    {
        // Act
        var beasts = await _generator.GenerateEnemiesAsync("beasts", 3);
        var undead = await _generator.GenerateEnemiesAsync("undead", 3);
        var humanoid = await _generator.GenerateEnemiesAsync("humanoid", 3);

        // Assert
        var totalEnemies = beasts.Count + undead.Count + humanoid.Count;
        // At least one category should have enemies
        totalEnemies.Should().BeGreaterThan(0, "At least one enemy category should contain enemies");

        // Check IDs are properly categorized
        foreach (var beast in beasts)
        {
            beast.Id.Should().StartWith("beasts:");
        }

        foreach (var undeadEnemy in undead)
        {
            undeadEnemy.Id.Should().StartWith("undead:");
        }

        foreach (var humanoidEnemy in humanoid)
        {
            humanoidEnemy.Id.Should().StartWith("humanoid:");
        }
    }
}